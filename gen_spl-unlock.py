import os
import struct
import sys

def err_exit(message, *args):
    sys.stderr.write(message % args)
    sys.exit(1)

def loadfile(fn, extra=0):
    try:
        with open(fn, "rb") as fi:
            fi.seek(0, os.SEEK_END)
            n = fi.tell()
            if n == 0:
                return None
            fi.seek(0, os.SEEK_SET)
            buf = fi.read(n)
            return buf + b'\x00' * extra  # Extra bytes for padding
    except Exception as e:
        return None

def patch_memory(mem):
    base_offset = struct.unpack_from("<I", mem, 0x30)[0]
    offset = 0x200
    while offset < base_offset + 0x200:
        if struct.unpack_from("<I", mem, offset)[0] == 0x34000060:
            if struct.unpack_from("<I", mem, offset - 4)[0] >> 8 == 0x940000:
                if struct.unpack_from("<H", mem, offset + 6)[0] == 0x5280:
                    # Patch instructions
                    struct.pack_into("<I", mem, offset - 4, 0xD503201F)
                    struct.pack_into("<I", mem, offset, 0xD503201F)
                    struct.pack_into("<I", mem, offset + 4, 0xD503201F)
                    struct.pack_into("<I", mem, offset + 8, 0xD503201F)
                    offset += 8
        offset += 4

def main(filename):
    mem = loadfile(filename)
    if not mem:
        err_exit("loadfile(\"%s\") failed\n", filename)

    size = len(mem)
    if size > 0xFFFFFFFF:
        err_exit("file too big\n")

    base_offset = struct.unpack_from("<I", mem, 0x30)[0]
    if base_offset == 0:
        err_exit("The file is not sprd trusted firmware\n")
    if base_offset + 0x200 > size:
        err_exit("The file is not complete\n")

    if struct.unpack_from("<I", mem, base_offset + 0x200 + 0x10)[0] != base_offset:
        size = base_offset + 0x200
    elif struct.unpack_from("<I", mem, base_offset + 0x200 + 0x50)[0]:
        size = struct.unpack_from("<I", mem, base_offset + 0x200 + 0x50)[0] + struct.unpack_from("<I", mem, base_offset + 0x200 + 0x58)[0]
    elif struct.unpack_from("<I", mem, base_offset + 0x200 + 0x30)[0]:
        size = struct.unpack_from("<I", mem, base_offset + 0x200 + 0x30)[0] + struct.unpack_from("<I", mem, base_offset + 0x200 + 0x38)[0]
    else:
        size = struct.unpack_from("<I", mem, base_offset + 0x200 + 0x20)[0] + struct.unpack_from("<I", mem, base_offset + 0x200 + 0x28)[0]

    print(f"0x{size:x}")

    # Write temp file and replace original
    try:
        with open("temp", "wb") as f:
            f.write(mem[:size])
    except Exception as e:
        err_exit("Failed to create/write the file.\n")

    try:
        os.remove(filename)
        os.rename("temp", filename)
    except Exception as e:
        err_exit("Failed to delete or rename the file.\n")

    # Patch memory
    patch_memory(mem)

    # Write patched file
    try:
        with open("spl-unlock.bin", "wb") as f:
            f.write(mem[:size])
    except Exception as e:
        err_exit("Failed to write the patched file.\n")

    # Free memory (not needed in Python but included for completeness)
    mem = None

if __name__ == "__main__":
    if len(sys.argv) < 2:
        err_exit("Usage: %s <filename>\n", sys.argv[0])

    main(sys.argv[1])
